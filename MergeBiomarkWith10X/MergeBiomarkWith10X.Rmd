---
title: "MergeBiomarkWith10X"
output:
  html_document:
    df_print: paged
---

# Updates


## 20211007
Gonna crank through LSK and MEP, then go back to the fluorophore data

## 20211005
Compared to archive 1, this version imports Biomark Ct spreadsheets that do not include fluorophore data 

# Setup
```{r setup}
knitr::opts_knit$set(root.dir = "~/Desktop/10XGenomicsData/msAggr_scRNASeq/MergeBiomarkWith10X/")
```

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(Seurat)
library(patchwork)
library(ggplot2)
library(cowplot)
library(clustree)
```

## Set global variables
```{r}
pop.of.interest <- "CMP"
cellranger.folder <- "m2"
fav.var <- 95
object.res <- ".0.5"
ident.list <- c("integrated_snn_res.0.5", "integrated_snn_res.1")
projectName <- paste0("MergeBiomarkWith10X_", pop.of.interest)
```

```{r}
source("~/Desktop/10XGenomicsData/msAggr_scRNASeq/RFunctions/ColorPalette.R")
source("~/Desktop/10XGenomicsData/msAggr_scRNASeq/RFunctions/PercentVariance.R")
source("~/Desktop/10XGenomicsData/msAggr_scRNASeq/RFunctions/read_10XGenomics_data.R")
source("~/Desktop/10XGenomicsData/msAggr_scRNASeq/RFunctions/Mouse2Human_idconversion.R")
```
store session info
```{r }
sink(paste0(projectName, "_sessionInfo.txt"))
sessionInfo()
sink()
```

# Create seurat object

## Load biomark data
Try to read in Biomark Data

```{r}
biomark.data <- read.table("/Users/heustonef/Desktop/10XGenomicsData/BioMark/Biomark_CT.txt", sep = "\t", header = TRUE, row.names = 1)
biomark.data[is.na(biomark.data)] <- 0

# Limit to biomark pop subset
biomark.data <- biomark.data[grepl(pop.of.interest, rownames(biomark.data)) == TRUE,]
dim(biomark.data)
```
```{r}
# fix non-MGI gene names
colnames(biomark.data)[colnames(biomark.data) == 'Cd117'] <- 'Kit'
colnames(biomark.data)[colnames(biomark.data) == 'Cd123'] <- 'Il3ra'
colnames(biomark.data)[colnames(biomark.data) == 'H2.Aa'] <- 'H2-Aa'
colnames(biomark.data)[colnames(biomark.data) == 'H2.Ab1'] <- 'H2-Ab1'
biomark.data <- subset(biomark.data, select = -Kng2)
```
Convert to pseudoexpression data
```{r}
# generate list of reference Ct averages, calculating average for ref genes where ref_gene Ct > 0
ref_list <- c("Actb", "B2m", "Kit")
biomark.data["refCt"] <- NA

for(i in 1:nrow(biomark.data)){
	ref_cts <- c()
	for(j in ref_list){
		if(biomark.data[i, j] > 0){
			ref_cts <- c(ref_cts, biomark.data[i, j])
		}
	}
	biomark.data[i, "refCt"] <- mean(ref_cts)
}

# generate dCt col
dbiomark.data <- biomark.data[, 1:ncol(biomark.data) -1]
dbiomark.data[dbiomark.data == 0] <- NA
dbiomark.data <- dbiomark.data - biomark.data[, "refCt"]

# create pseudo expression matrix
pseudo.biomark <- 2^-dbiomark.data

```





```{r warning=FALSE, message=FALSE}
biomark.meta <- data.frame(stringr::str_split_fixed(rownames(pseudo.biomark), "_", 3)[,2:3], row.names = rownames(pseudo.biomark))
colnames(biomark.meta) <- c("wid", "pid")

pseudo.biomark.T <- data.table::transpose(pseudo.biomark)
colnames(pseudo.biomark.T) <- rownames(pseudo.biomark)
rownames(pseudo.biomark.T) <- colnames(pseudo.biomark)

biomark.meta['nFeature_RNA'] <- NA
for(cell in colnames(pseudo.biomark.T)){
	ngenes <- length(which(!(pseudo.biomark.T[colnames(pseudo.biomark.T > 0) == cell])))
	biomark.meta[rownames(biomark.meta) == cell, 'nFeature_RNA'] <- ngenes
}

```

```{r}
pseudo.biomark.T[is.na(pseudo.biomark.T)] <- 0
pseudo.biomark.T <- as.sparse(pseudo.biomark.T)
biomark.object <- CreateSeuratObject(pseudo.biomark.T, project = "Biomark", assay = "RNA", meta.data = biomark.meta)
```

## Load SC data

```{r warning=FALSE}
setwd("~/Desktop/10XGenomicsData/cellRanger/") # temporarily changing wd only works if you run the entire chunk at once
data_file.list <- read_10XGenomics_data(sample.list = paste0(pop.of.interest, cellranger.folder))
object.data <-Read10X(data_file.list)
sc.object<- CreateSeuratObject(counts = object.data, min.cells = 3, min.genes = 200, project = "10X")
```


Keep only genes in both objects

```{r}
shared.features <- intersect(rownames(biomark.object@assays$RNA@data), rownames(sc.object@assays$RNA@data))
sc.object <- subset(sc.object, features = shared.features)
biomark.object <- subset(biomark.object, features = shared.features)
sc.object@meta.data["wid"] <- '10X'
sc.object@meta.data["pid"] <- "p14"

# Check that there's a clean overlap
setdiff(rownames(biomark.object@assays$RNA@data), rownames(sc.object@assays$RNA@data))
```

Clean up to free memory

```{r}
remove(object.data, biomark.data, biomark.meta)
```

## merge objects
```{r}
seurat.object <- merge(sc.object, biomark.object, project = 'mergebiomark')
seurat.object@meta.data$orig.ident[seurat.object@meta.data$orig.ident == paste0(pop.of.interest, cellranger.folder)] <- '10X'
seurat.object@meta.data$orig.ident[seurat.object@meta.data$orig.ident == pop.of.interest] <- 'Biomark'
# seurat.object@meta.data[is.na(seurat.object@meta.data)] <- 0
# seurat.object@meta.data$orig.ident <- factor(seurat.object@meta.data$orig.ident)
# seurat.object@meta.data$pid <- factor(seurat.object@meta.data$pid)
# seurat.object@meta.data$wid <- factor(seurat.object@meta.data$wid)
seurat.object
```

# Traditional normalize and scaling approaches
trying sctransform and normalizeData/scaledata
```{r}
# seurat.object <- SCTransform(seurat.object, vars.to.regress = c("wid"))
seurat.object <- NormalizeData(seurat.object, normalization.method = "LogNormalize", scale.factor = 10000)
seurat.object <- FindVariableFeatures(seurat.object, selection.method = "vst", nfeatures = 10)
```

Scale data (linear transformation)

```{r}
all.genes <- rownames(seurat.object)
seurat.object <- ScaleData(seurat.object, features = all.genes, vars.to.regress = c("wid", "pid", "orig.ident"))
```

### Save merged object
```{r}
saveRDS(seurat.object, file = paste0(projectName, "_raw.RDS"))
```
## Run PCA
```{r}
seurat.object <- RunPCA(seurat.object, ndims.print = 1:5, nfeatures.print = 5, features = all.genes)
```


```{r}
DimPlot(seurat.object, reduction = "pca", group.by = "orig.ident")
```

```{r}
VizDimLoadings(seurat.object, dims = 1:6, nfeatures = 10, reduction = "pca", ncol = 3)

```

Calculate dimensionality
```{r, figures-side, fig.show='hold', out.width="50%"}
ElbowPlot(seurat.object, ndims = 50)
percent.variance(seurat.object@reductions$pca@stdev)
```




## Calculate percent variance
```{r}
tot.var <- percent.variance(seurat.object@reductions$pca@stdev, plot.var = FALSE, return.val = TRUE)
paste0("Num pcs for 80% variance:", length(which(cumsum(tot.var) <= 80)))
paste0("Num pcs for 85% variance:", length(which(cumsum(tot.var) <= 85)))
paste0("Num pcs for 90% variance:", length(which(cumsum(tot.var) <= 90)))
paste0("Num pcs for 95% variance:", length(which(cumsum(tot.var) <= 95)))

```

# scRNASeq integration	
neither sctransform nor normalizedata/scaledata gave what looked like reasonable results.

https://satijalab.org/seurat/articles/integration_introduction.html


```{r}
tech.list <- c(sc.object, biomark.object)
tech.list <- lapply(X = tech.list, FUN = function(x) {
	x <- NormalizeData(x)
	x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 10)
})
```


## identify anchors
```{r}

tech.anchors <- FindIntegrationAnchors(object.list = tech.list, anchor.features = all.genes, k.anchor = 20, k.filter = NA)
# tech.integrated <- IntegrateData(anchorset = tech.anchors, dims = 1:30, k.weight = 20, normalization.method = "SCT")
tech.integrated <- IntegrateData(anchorset = tech.anchors, k.weight = 5)
```

## tech.integrated PCA

```{r}
DefaultAssay(tech.integrated) <- "integrated"
tech.integrated <- ScaleData(tech.integrated)
tech.integrated <- RunPCA(tech.integrated, npcs = 30)
DimPlot(tech.integrated, reduction = "pca", group.by = "orig.ident", pt.size = 2)
```

so it looks like anchor-based integration is much nicer! goign to stick with this approach.



Number of PCs describing X% of variance

```{r}
tot.var <- percent.variance(tech.integrated@reductions$pca@stdev, plot.var = FALSE, return.val = TRUE)
paste0("Num pcs for 80% variance: ", length(which(cumsum(tot.var) <= 80)))
paste0("Num pcs for 85% variance: ", length(which(cumsum(tot.var) <= 85)))
paste0("Num pcs for 90% variance: ", length(which(cumsum(tot.var) <= 90)))
paste0("Num pcs for 95% variance: ", length(which(cumsum(tot.var) <= 95)))

```


# ID clusters based on different variances
## Describe 80% of variance 

### Neighborhood and umap
```{r}
tot.var <- percent.variance(tech.integrated@reductions$pca@stdev, plot.var = FALSE, return.val = TRUE)
pct.var <- 80
ndims <- length(which(cumsum(tot.var) <= pct.var))
print(ndims)

tech.integrated <- FindNeighbors(tech.integrated, dims = 1:ndims)
tech.integrated <- FindClusters(tech.integrated, resolution = 0.5)
tech.integrated <- RunUMAP(tech.integrated, dims = 1: ndims)
```
find clusters

```{r}
for(x in c(0.5, 1, 1.5)){
	tech.integrated <- FindClusters(tech.integrated, resolution = x)
}
```

```{r}
for (meta.col in colnames(tech.integrated@meta.data)){
	if(grepl(pattern = "integrated_snn_res", x = meta.col)==TRUE | grepl(pattern = "orig.ident", x = meta.col)==TRUE){
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col) ))
		plot(myplot)
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			facet_wrap(meta.col) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col)))
		
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap_FacetRes.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		
	}
}
```

```{r}
saveRDS(tech.integrated, file = paste0(projectName, "_pctVar", pct.var, ".RDS"))
```

### Evaluate cluster stability
```{r fig.height=5}
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") + 
	scale_color_continuous(low = 'red3', high = 'white')
png(filename = paste0(projectName, "_pctVar", pct.var, "-clustree.png"), height = 800, width = 1600)
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") +
	scale_color_continuous(low = 'red3', high = 'white')
dev.off()
```







## Describe 85% of variance 

### Neighborhood and umap
```{r}
tot.var <- percent.variance(tech.integrated@reductions$pca@stdev, plot.var = FALSE, return.val = TRUE)
pct.var <- 85
ndims <- length(which(cumsum(tot.var) <= pct.var))
print(ndims)

tech.integrated <- FindNeighbors(tech.integrated, dims = 1:ndims)
tech.integrated <- FindClusters(tech.integrated, resolution = 0.5)
tech.integrated <- RunUMAP(tech.integrated, dims = 1: ndims)
```
Plot UMAP

```{r}
for(x in c(0.5, 1, 1.5)){
	tech.integrated <- FindClusters(tech.integrated, resolution = x)
}
```

```{r}
for (meta.col in colnames(tech.integrated@meta.data)){
	if(grepl(pattern = "integrated_snn_res", x = meta.col)==TRUE | grepl(pattern = "orig.ident", x = meta.col)==TRUE){
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col) ))
		plot(myplot)
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			facet_wrap(meta.col) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col)))
		
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap_FacetRes.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		
	}
}
```

```{r}
saveRDS(tech.integrated, file = paste0(projectName, "_pctVar", pct.var, ".RDS"))
```

### Evaluate cluster stability
```{r fig.height=5}
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") + 
	scale_color_continuous(low = 'red3', high = 'white')
png(filename = paste0(projectName, "_pctVar", pct.var, "-clustree.png"), height = 800, width = 1600)
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") +
	scale_color_continuous(low = 'red3', high = 'white')
dev.off()
```






## Describe 90% of variance 

### Neighborhood and umap
```{r}
tot.var <- percent.variance(tech.integrated@reductions$pca@stdev, plot.var = FALSE, return.val = TRUE)
pct.var <- 90
ndims <- length(which(cumsum(tot.var) <= pct.var))
print(ndims)

tech.integrated <- FindNeighbors(tech.integrated, dims = 1:ndims)
tech.integrated <- FindClusters(tech.integrated, resolution = 0.5)
tech.integrated <- RunUMAP(tech.integrated, dims = 1: ndims)
```
Plot UMAP

```{r}
for(x in c(0.5, 1, 1.5)){
	tech.integrated <- FindClusters(tech.integrated, resolution = x)
}
```

```{r}
for (meta.col in colnames(tech.integrated@meta.data)){
	if(grepl(pattern = "integrated_snn_res", x = meta.col)==TRUE | grepl(pattern = "orig.ident", x = meta.col)==TRUE){
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col) ))
		plot(myplot)
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			facet_wrap(meta.col) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col)))
		
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap_FacetRes.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		
	}
}
```

```{r}
saveRDS(tech.integrated, file = paste0(projectName, "_pctVar", pct.var, ".RDS"))
```

### Evaluate cluster stability
```{r fig.height=5}
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") + 
	scale_color_continuous(low = 'red3', high = 'white')
png(filename = paste0(projectName, "_pctVar", pct.var, "-clustree.png"), height = 800, width = 1600)
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") +
	scale_color_continuous(low = 'red3', high = 'white')
dev.off()
```






## Describe 95% of variance 

### Neighborhood and umap
```{r}
tot.var <- percent.variance(tech.integrated@reductions$pca@stdev, plot.var = FALSE, return.val = TRUE)
pct.var <- 95
ndims <- length(which(cumsum(tot.var) <= pct.var))
print(ndims)

tech.integrated <- FindNeighbors(tech.integrated, dims = 1:ndims)
tech.integrated <- FindClusters(tech.integrated, resolution = 0.5)
tech.integrated <- RunUMAP(tech.integrated, dims = 1: ndims)
```
Plot UMAP

```{r warning=FALSE, results='hide'}
for(x in c(0.5, 1, 1.5, 2, 2.5)){
	tech.integrated <- FindClusters(tech.integrated, resolution = x)
}
```

```{r}
for (meta.col in colnames(tech.integrated@meta.data)){
	if(grepl(pattern = "integrated_snn_res", x = meta.col)==TRUE | grepl(pattern = "orig.ident", x = meta.col)==TRUE){
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col) ))
		plot(myplot)
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		myplot <- DimPlot(tech.integrated, 
											group.by = meta.col,
											reduction = "umap", 
											pt.size = 1,
											cols = color.palette) + 
			facet_wrap(meta.col) + 
			ggtitle(paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col)))
		
		png(filename = paste0(projectName, " pctVar", pct.var, "res.", gsub("integrated_snn_res.", "", meta.col), "-umap_FacetRes.png"), height = 800, width = 800)
		plot(myplot)
		dev.off()
		
	}
}
```
### Evaluate cluster stability
```{r fig.height=5}
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") + 
	scale_color_continuous(low = 'red3', high = 'white')
png(filename = paste0(projectName, "_pctVar", pct.var, "-clustree.png"), height = 800, width = 1600)
clustree(tech.integrated, prefix = "integrated_snn_res.", node_colour = "sc3_stability") +
	scale_color_continuous(low = 'red3', high = 'white')
dev.off()
```


# Pick set of conditions to investigate further
Now that have checked multiple pct.vars and object.res's, pick the favourite combination and do more detailed characerization of the. This includes:
* Stats on each cluster
* Find markers
* Export lists for GSEA


## Reload object 
```{r}
tech.integrated <- readRDS(paste0(projectName, "_pctVar", fav.var, ".RDS"))
tech.integrated <- SetIdent(tech.integrated, value = paste0("integrated_snn_res", object.res))
```


for each resolution, number/percentage of cells in each cluster?

```{r}
tot.cells <- nrow(tech.integrated@meta.data)
for (meta.col in colnames(tech.integrated@meta.data)){
	if(grepl(pattern = ("integrated_snn_res"), x = meta.col)==TRUE){
		new.clusters <- sort(as.numeric(levels(tech.integrated@meta.data[[meta.col]])))
		stats.df <- data.frame(matrix(ncol = 2, nrow = length(new.clusters)))
		colnames(stats.df) <- c("num_cells", "pct_pop")
		rownames(stats.df) <- new.clusters
		meta.df <- tech.integrated@meta.data
		for(row.id in rownames(stats.df)){
			num.x <- nrow(meta.df[meta.df[meta.col] == row.id,])
			pct.x <- as.integer(num.x / tot.cells *100)
			# print(pct.x)
			stats.df[row.id, "num_cells"] <- num.x
			stats.df[row.id, "pct_pop"] <- pct.x
		}
		print(stats.df)
	}
}
```
```{r}
tech.integrated <- readRDS("")
```


```{r}
current_res <- 'integrated_snn_res.0.5'
tech.integrated@meta.data$orig.ident[tech.integrated@meta.data$orig.ident == paste0(pop.of.interest, cellranger.folder)] <- "10X"
tech.integrated@meta.data$orig.ident[tech.integrated@meta.data$orig.ident == paste0(pop.of.interest)] <- "biomark"
tech.integrated@meta.data$orig.ident <- factor(tech.integrated@meta.data$orig.ident)


cluster_ids <- sort(unique(tech.integrated@meta.data[,current_res]))
counts_df <- data.frame(matrix(nrow = length(cluster_ids), ncol = 4))
rownames(counts_df) <- cluster_ids
colnames(counts_df) <- c("10X", "biomark", "pct10X", "pctbiomark")
tot.10X <- nrow(tech.integrated@meta.data[tech.integrated@meta.data$orig.ident == "10X", ])
tot.biomark <- nrow(tech.integrated@meta.data[tech.integrated@meta.data$orig.ident == "biomark", ])
for(id in cluster_ids){
	cell_value <- nrow(tech.integrated@meta.data[(tech.integrated@meta.data[current_res] == id) & 
																							 	(tech.integrated@meta.data$orig.ident == "10X"),])
	counts_df[id, "10X"] = cell_value
	counts_df[id, "pct10X"] = round(cell_value/tot.10X*100, 2)
	cell_value <- nrow(tech.integrated@meta.data[(tech.integrated@meta.data[current_res] == id) & 
																							 	(tech.integrated@meta.data$orig.ident == "biomark"),])
	counts_df[id, "biomark"] = cell_value
	counts_df[id, "pctbiomark"] = round(cell_value/tot.biomark*100, 2)
}
try(xlsx::write.xlsx(x = counts_df, 
								 file = paste0(projectName, " pctVar", pct.var, "_stats.xlsx"), 
								 sheetName = "cluster_stats", 
								 col.names = TRUE, 
								 row.names = TRUE, 
								 append = TRUE)
)
counts_df
```






## Create `FindAllMarkers()` lists for GSEA
```{r}
ident.list <- c("integrated_snn_res.0.5")

for(tested.ident in ident.list){
	Idents(tech.integrated) <- tested.ident
	all.markers <- FindAllMarkers(tech.integrated)
	xlsx::write.xlsx(x = all.markers[,c("avg_log2FC", "p_val_adj", "cluster", "gene")], 
									 file = paste0(projectName, " pctVar", pct.var, "_allres.xlsx"), 
									 sheetName = tested.ident, 
									 col.names = TRUE, 
									 row.names = FALSE, 
									 append = TRUE)
}
```

## Map HGNC symbols
```{r}
tech.integrated <- SetIdent(tech.integrated, value = paste0("integrated_snn_res", object.res))
object.res.allmarkers <- FindAllMarkers(tech.integrated)
Mouse2HumanTable <- Mouse2Human(object.res.allmarkers$gene)

HGNC <- with(Mouse2HumanTable, Mouse2HumanTable$HGNC[match(object.res.allmarkers$gene, Mouse2HumanTable$MGI)])
head(object.res.allmarkers)
object.res.allmarkers$HGNC <- HGNC
tail(object.res.allmarkers)
sig.res <- object.res.allmarkers[object.res.allmarkers$p_val_adj <= 0.05, ]
sig.res <- sig.res[c("avg_log2FC", "HGNC", "cluster")]
sig.res <- sig.res[!(sig.res$HGNC == "" | is.na(sig.res$HGNC)),] # GSEA will fail if there are any blanks or NAs in the table
sig.res <- sig.res[]

```


```{r}
for(cluster in unique(sig.res$cluster)){
	print(paste("writing cluster", cluster))
	new.table <- sig.res[sig.res$cluster == cluster, c("HGNC", "avg_log2FC")]
	new.table <- new.table[order(-new.table$avg_log2FC), ]
	try(dir.create(paste0("RankList_pctVar", pct.var, "res", object.res, "_findAll_hgnc/"), showWarnings = FALSE))
	try(write.table(new.table, file = paste0("RankList_pctVar", pct.var, "res", object.res, "_findAll_hgnc/", projectName, "pctVar", pct.var, "res", object.res, "cluster", cluster, ".rnk"), quote = FALSE, row.names = FALSE, col.names = TRUE, sep = "\t", ))
	
}
```



